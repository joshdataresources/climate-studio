# Implementation Summary: Rivers to Metro Cities

## âœ… What Has Been Created

### 1. Planning Documents
- **`PLAN_RIVERS_TO_METROS.md`**: Comprehensive implementation plan with phases, criteria, and technical considerations
- **`RIVERS_TO_METROS_EXAMPLES.md`**: Examples of target rivers, data structures, and connection types

### 2. Data Files
- **`metro-connecting-rivers.json`**: Starter dataset with 5 example rivers (Salt, Catawba, Cumberland, Boise, Neuse)
- **`river-metro-curation-template.json`**: Template generated by script for manual research
- **`river-metro-summary.json`**: Analysis summary showing 31 metros need connections

### 3. Tools & Scripts
- **`scripts/match-rivers-to-metros.js`**: Analysis tool that:
  - Identifies metros without river connections
  - Finds nearby rivers (proximity-based)
  - Generates curation templates
  - Creates summary reports

### 4. Utility Functions
- **`src/utils/riverMetroConnections.ts`**: TypeScript utilities for:
  - Finding rivers for specific metros
  - Filtering rivers by criteria
  - Getting river colors based on flow depletion
  - Getting rivers for visible metros

## ðŸ“Š Current Status

### Analysis Results
- **Total Metro Cities**: 50
- **Already Connected**: 19 (38%)
- **Needs Connection**: 31 (62%)

### Top Priority Unconnected Metros
1. Chicago (9.5M) - Great Lakes (may not need river, uses lake water)
2. Houston (7.2M) - Texas
3. Miami (6.2M) - Florida
4. Boston (4.9M) - Northeast
5. San Francisco (4.7M) - Northern California
6. Detroit (4.3M) - Great Lakes
7. Seattle (4.0M) - Northwest
8. Tampa (3.2M) - Florida
9. Charlotte (2.7M) - Southeast (Catawba River - already in template!)
10. Orlando (2.7M) - Florida

### Rivers in Dataset
- **Major Rivers** (>10k CFS): 7 (already documented)
- **Significant Rivers** (500-10k CFS): 4 (target for this feature)
- **Feeder Rivers** (<500 CFS): 0

## ðŸŽ¯ Next Steps

### Phase 1: Data Collection (Immediate)
1. **Review the curation template** (`river-metro-curation-template.json`)
   - Contains all 31 unconnected metros
   - Shows nearby rivers for each (within 100km)
   - Ready for manual research

2. **Research top 10 unconnected metros**
   - Focus on cities with high population
   - Identify primary water source rivers
   - Determine dependency percentages
   - Note water access risk levels

3. **Add to `metro-connecting-rivers.json`**
   - Use the example structure as a template
   - Include flow projections (2025-2125)
   - Add connection details and risk factors

### Phase 2: Integration (Short-term)
1. **Enhance MegaregionLayer Component**
   ```typescript
   // Add river visualization when metro layer is active
   import { getRiversForVisibleMetros } from '../utils/riverMetroConnections'
   
   // In MegaregionLayer component:
   const connectingRivers = getRiversForVisibleMetros(
     visibleMetroNames,
     projectionYear
   )
   ```

2. **Add River Layer to Map**
   - Show connecting rivers as lines
   - Color-code by flow depletion
   - Add connection lines from rivers to metros
   - Make toggleable in layer controls

3. **Add Interactive Features**
   - Click river â†’ show connected metros
   - Click metro â†’ show all connecting rivers
   - Show water dependency percentages
   - Display water access risk levels

### Phase 3: UI/UX (Medium-term)
1. **Layer Controls**
   - Add "Connecting Rivers" toggle to Metro Statistics controls
   - Filter options:
     - Show all connecting rivers
     - Show only high-risk rivers
     - Show only critical impact rivers

2. **Legend & Information**
   - River flow depletion colors
   - Connection type line styles
   - Water access risk levels
   - Info panel explaining the feature

3. **Details Panel**
   - Show metro water dependency summary
   - List all connecting rivers
   - Display total dependency percentage
   - Show highest risk level

## ðŸ”§ Technical Implementation Guide

### Step 1: Add Rivers to MegaregionLayer

```typescript
// In MegaregionLayer.tsx
import { getRiversForVisibleMetros } from '../utils/riverMetroConnections'

export function MegaregionLayer({ year, opacity, visible }: MegaregionLayerProps) {
  // ... existing code ...
  
  // Get visible metro names
  const visibleMetroNames = data.metros.map(m => m.name)
  
  // Get connecting rivers
  const connectingRivers = getRiversForVisibleMetros(visibleMetroNames, year)
  
  // Create GeoJSON for rivers
  const riversGeoJSON = useMemo(() => {
    if (!visible || connectingRivers.length === 0) return null
    
    return {
      type: 'FeatureCollection' as const,
      features: connectingRivers.map(river => ({
        type: 'Feature' as const,
        properties: {
          name: river.properties.name,
          lineColor: river.properties.lineColor,
          // ... other properties
        },
        geometry: river.geometry
      }))
    }
  }, [connectingRivers, visible, year])
  
  return (
    <>
      {/* Existing metro circles */}
      
      {/* Add river layer */}
      {riversGeoJSON && (
        <Source id="metro-connecting-rivers" type="geojson" data={riversGeoJSON}>
          <Layer
            id="metro-rivers-lines"
            type="line"
            paint={{
              'line-color': ['get', 'lineColor'],
              'line-width': 3,
              'line-opacity': opacity * 0.7
            }}
          />
        </Source>
      )}
    </>
  )
}
```

### Step 2: Add Connection Lines

```typescript
// Create connection lines from rivers to metros
const connectionLines = useMemo(() => {
  if (!visible || !riversGeoJSON) return null
  
  const lines: any[] = []
  
  connectingRivers.forEach(river => {
    const cities = river.properties.metro_cities || 
                   river.properties.cities_supplied || []
    
    cities.forEach((city: any) => {
      // Find closest point on river to city
      const riverCoords = river.geometry.coordinates
      const cityCoords = [city.lng, city.lat]
      
      // Create line from river to city
      lines.push({
        type: 'Feature',
        properties: {
          riverName: river.properties.name,
          metroName: city.name,
          connectionType: city.connection_type || 'primary_source'
        },
        geometry: {
          type: 'LineString',
          coordinates: [riverCoords[0], cityCoords]
        }
      })
    })
  })
  
  return {
    type: 'FeatureCollection',
    features: lines
  }
}, [connectingRivers, visible])
```

### Step 3: Add Layer Controls

```typescript
// In climateLayers.ts or layer controls component
controls: [
  'megaregionDataMode',
  'megaregionOpacity',
  'megaregionAnimating',
  'showConnectingRivers', // Add this
  'riverRiskFilter' // Optional: filter by risk
]
```

## ðŸ“ Data Curation Guidelines

### For Each Metro City:
1. **Identify Primary Water Sources**
   - Research city water department reports
   - Check state water supply plans
   - Review drought contingency plans

2. **Determine River Significance**
   - Flow: 500-10,000 CFS (target range)
   - Dependency: >20% of city's water
   - Upstream: River must be upstream of city

3. **Calculate Projections**
   - Use climate projections for flow decline
   - Consider snowpack decline (western states)
   - Factor in population growth
   - Account for agricultural demand

4. **Assess Risk**
   - High: >30% flow decline by 2050, limited alternatives
   - Medium: 15-30% decline, some alternatives
   - Low: <15% decline, multiple alternatives

### Example Research Sources:
- USGS Water Data: https://waterdata.usgs.gov/
- EPA Watershed Data: https://www.epa.gov/waterdata
- City Water Department Reports
- State Water Supply Plans
- Climate Projections (NOAA, USGS)

## ðŸŽ¨ Visualization Design

### River Colors (Flow Depletion)
- **Green** (#22c55e): â‰¥95% of baseline (Stable)
- **Blue** (#3b82f6): 80-95% (Moderate decline)
- **Orange** (#f97316): 60-80% (Significant decline)
- **Red** (#ef4444): <60% (Severe decline)

### Connection Line Styles
- **Primary Source**: Bold solid line (3px)
- **Significant Supply**: Medium dashed line (2px)
- **Upstream Limiting**: Thin dotted line (1px)

### Metro Indicators
- Add icon/badge to metros with high water risk
- Show total dependency percentage
- Highlight metros with critical rivers

## âœ… Success Criteria

1. âœ… All major metro cities have at least one connecting river shown
2. âœ… Rivers are filtered appropriately (not major, not feeder)
3. âœ… Water access limitations are clearly visualized
4. âœ… Urban prosperity impact is communicated
5. âœ… Integration with Metro Statistics layer is seamless
6. âœ… Performance is acceptable (no lag when toggling)

## ðŸš€ Quick Start

1. **Run the analysis script**:
   ```bash
   node scripts/match-rivers-to-metros.js
   ```

2. **Review the template**:
   - Open `apps/climate-studio/src/data/river-metro-curation-template.json`
   - Focus on top 10 unconnected metros

3. **Research and add rivers**:
   - Use examples in `RIVERS_TO_METROS_EXAMPLES.md`
   - Add to `metro-connecting-rivers.json`

4. **Integrate into component**:
   - Use utilities from `riverMetroConnections.ts`
   - Add to `MegaregionLayer.tsx`
   - Test with a few metros first

5. **Iterate and refine**:
   - Start with high-priority metros
   - Add more as data becomes available
   - Refine visualization based on feedback

## ðŸ“š Related Files

- `apps/climate-studio/src/components/MegaregionLayer.tsx` - Main component to enhance
- `apps/climate-studio/src/data/rivers.json` - Existing major rivers
- `apps/climate-studio/src/data/megaregion-data.json` - Metro cities data
- `packages/climate-core/src/config/climateLayers.ts` - Layer configuration

## ðŸ’¡ Tips

1. **Start Small**: Begin with 5-10 well-researched metros
2. **Prioritize**: Focus on high-population, water-stressed cities
3. **Validate**: Cross-reference multiple sources for accuracy
4. **Iterate**: Add more rivers as you research
5. **Test**: Test visualization with real data before full integration
